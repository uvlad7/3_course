<HTML>
<HEAD>
<TITLE>Современные высокопроизводительные компьютеры - Иерархия памяти</TITLE>
</head>

<body bgcolor="#FFFFFF" link="#950995" vlink="#650065" alink="#800000" text="#000000">
<H2><A NAME = "Иерархия памяти">Иерархия памяти</A></H2>
<UL>
    <LI><A HREF = "#Иерархия памяти">Иерархия памяти</A>
    <UL TYPE = disc>
        <LI><A HREF = "#Введение">Введение</A>
        <LI><A HREF = "#Организация кэш-памяти">Организация кэш-памяти</A>
        <LI><A HREF = "glava_8_1.htm#Принципы организации основной памяти в современных компьютерах">Принципы организации основной памяти в современных компьютерах</A>
        <UL TYPE = disc>
            <LI><A HREF = "glava_8_1.htm#Общие положения">Общие положения</A>
            <LI><A HREF = "glava_8_1.htm#Увеличение разрядности основной памяти">Увеличение разрядности основной памяти</A>
            <LI><A HREF = "glava_8_1.htm#Память с расслоением">Память с расслоением</A>
            <LI><A HREF = "glava_8_1.htm#Использование специфических свойств динамических ЗУПВ">Использование специфических свойств динамических ЗУПВ</A>
        </UL>
        <LI><A HREF = "glava_8_1.htm#Виртуальная память и организация защиты памяти">Виртуальная память и организация защиты памяти</A>
        <UL TYPE = disc>
            <LI><A HREF = "glava_8_1.htm#Концепция виртуальной памяти">Концепция виртуальной памяти</A>
            <LI><A HREF = "glava_8_1.htm#Страничная организация памяти">Страничная организация памяти</A>
            <LI><A HREF = "glava_8_1.htm#Сегментация памяти">Сегментация памяти</A>
        </UL>
    </UL>
</UL>
<H3><A NAME = "Введение">Введение</A></H3>
<P>
В основе реализации иерархии памяти современных компьютеров лежат два принципа: принцип локальности обращений и соотношение стоимость/производительность. Принцип локальности обращений говорит о том, что большинство программ к счастью не выполняют обращений ко всем своим командам и данным равновероятно, а оказывают предпочтение некоторой части своего адресного пространства.
<P>
Иерархия памяти современных компьютеров строится на нескольких уровнях, причем более высокий уровень меньше по объему, быстрее и имеет большую стоимость в пересчете на байт, чем более низкий уровень. Уровни иерархии взаимосвязаны: все данные на одном уровне могут быть также найдены на более низком уровне, и все данные на этом более низком уровне могут быть найдены на следующем нижележащем уровне и так далее, пока мы не достигнем основания иерархии.
<P>
Иерархия памяти обычно состоит из многих уровней, но в каждый момент времени мы имеем дело только с двумя близлежащими уровнями. Минимальная единица информации, которая может либо присутствовать, либо отсутствовать в двухуровневой иерархии, называется блоком. Размер блока может быть либо фиксированным, либо переменным. Если этот размер зафиксирован, то объем памяти является кратным размеру блока.
<P>
Успешное или неуспешное обращение к более высокому уровню называются соответственно попаданием (hit) или промахом (miss). Попадание - есть обращение к объекту в памяти, который найден на более высоком уровне, в то время как промах означает, что он не найден на этом уровне. Доля попаданий (hit rate) или коэффициент попаданий (hit ratio) есть доля обращений, найденных на более высоком уровне. Иногда она представляется процентами. Доля промахов (miss rate) есть доля обращений, которые не найдены на более высоком уровне.
<P>
Поскольку повышение производительности является главной причиной появления иерархии памяти, частота попаданий и промахов является важной характеристикой. Время обращения при попадании (hit time) есть время обращения к более высокому уровню иерархии, которое включает в себя, в частности, и время, необходимое для определения того, является ли обращение попаданием или промахом. Потери на промах (miss penalty) есть время для замещения блока в более высоком уровне на блок из более низкого уровня плюс время для пересылки этого блока в требуемое устройство (обычно в процессор). Потери на промах далее включают в себя две компоненты: время доступа (access time) - время обращения к первому слову блока при промахе, и время пересылки (transfer time) - дополнительное время для пересылки оставшихся слов блока. Время доступа связано с задержкой памяти более низкого уровня, в то время как время пересылки связано с полосой пропускания канала между устройствами памяти двух смежных уровней.
<P>
Чтобы описать некоторый уровень иерархии памяти надо ответить на следующие четыре вопроса:
<P>
1. Где может размещаться блок на верхнем уровне иерархии? (размещение блока).
<P>
2. Как найти блок, когда он находится на верхнем уровне? (идентификация блока).
<P>
3. Какой блок должен быть замещен в случае промаха? (замещение блоков).
<P>
4. Что происходит во время записи? (стратегия записи).
<H3><A NAME = "Организация кэш-памяти">Организация кэш-памяти</A></H3>
<P>
Концепция кэш-памяти возникла раньше чем архитектура IBM/360, и сегодня кэш-память имеется практически в любом классе компьютеров, а в некоторых компьютерах - во множественном числе.
<P>
Все термины, которые были определены раньше могут быть использованы и для кэш-памяти, хотя слово &quot;строка&quot; (line) часто употребляется вместо слова &quot;блок&quot; (block).
<P>
На рис. 7.1 представлен типичный набор параметров, который используется для описания кэш-памяти.
<table border=1>
<tr><td align=left colspan= 85>Размер блока (строки) <td align=left colspan= 71>4-128 байт
<tr><td align=left colspan= 85>Время попадания (hit time)<td align=left colspan= 71>1-4 такта синхронизации<br>(обычно 1 такт)
<tr><td align=left colspan= 85>Потери при промахе (miss penalty)<br>(Время доступа - access time)<br>(Время пересылки - transfer time)<td align=left colspan= 71>8-32 такта синхронизации<br>(6-10 тактов синхронизации)<br>(2-22 такта синхронизации)
<tr><td align=left colspan= 85>Доля промахов (miss rate)<td align=left colspan= 71>1%-20%
<tr><td align=left colspan= 85>Размер кэш-памяти<td align=left colspan= 71>4 Кбайт - 16 Мбайт
</table>
<P ALIGN = center>
<I>Рис. 7.1. Типовые значения ключевых параметров для кэш-памяти рабочих станций и серверов.</I>
<P>
Рассмотрим организацию кэш-памяти более детально, отвечая на четыре вопроса об иерархии памяти.
<P>
<B>1. Где может размещаться блок в кэш-памяти?</B>
<P>
Принципы размещения блоков в кэш-памяти определяют три основных типа их организации:
<UL TYPE = disc>
<LI>Если каждый блок основной памяти имеет только одно фиксированное место, на котором он может появиться в кэш-памяти, то такая кэш-память называется кэшем с прямым отображением (direct mapped). Это наиболее простая организация кэш-памяти, при которой для отображение адресов блоков основной памяти на адреса кэш-памяти просто используются младшие разряды адреса блока. Таким образом, все блоки основной памяти, имеющие одинаковые младшие разряды в своем адресе, попадают в один блок кэш-памяти, т.е.
</UL>
<P>
(адрес блока кэш-памяти) =
<br>
<P>
(адрес блока основной памяти) mod (число блоков в кэш-памяти)
<UL TYPE = disc>
<LI>Если некоторый блок основной памяти может располагаться на любом месте кэш-памяти, то кэш называется полностью ассоциативным (fully associative).
<LI>Если некоторый блок основной памяти может располагаться на ограниченном множестве мест в кэш-памяти, то кэш называется множественно-ассоциативным (set associative). Обычно множество представляет собой группу из двух или большего числа блоков в кэше. Если множество состоит из n блоков, то такое размещение называется множественно-ассоциативным с n каналами (n-way set associative). Для размещения блока прежде всего необходимо определить множество. Множество определяется младшими разрядами адреса блока памяти (индексом):
</UL>
<P>
(адрес множества кэш-памяти) =
<br>
<P>
(адрес блока основной памяти) mod (число множеств в кэш-памяти)
<P>
Далее, блок может размещаться на любом месте данного множества.
<P>
Диапазон возможных организаций кэш-памяти очень широк: кэш-память с прямым отображением есть просто одноканальная множественно-ассоциативная кэш-память, а полностью ассоциативная кэш-память с m блоками может быть названа m-канальной множественно-ассоциативной. В современных процессорах как правило используется либо кэш-память с прямым отображением, либо двух- (четырех-) канальная множественно-ассоциативная кэш-память.
<P>
<B>2. Как найти блок, находящийся в кэш-памяти?</B>
<P>
У каждого блока в кэш-памяти имеется адресный тег, указывающий, какой блок в основной памяти данный блок кэш-памяти представляет. Эти теги обычно одновременно сравниваются с выработанным процессором адресом блока памяти.
<P>
Кроме того, необходим способ определения того, что блок кэш-памяти содержит достоверную или пригодную для использования информацию. Наиболее общим способом решения этой проблемы является добавление к тегу так называемого бита достоверности (valid bit).
<P>
Адресация множественно-ассоциативной кэш-памяти осуществляется путем деления адреса, поступающего из процессора, на три части: поле смещения используется для выбора байта внутри блока кэш-памяти, поле индекса определяет номер множества, а поле тега используется для сравнения. Если общий размер кэш-памяти зафиксировать, то увеличение степени ассоциативности приводит к увеличению количества блоков в множестве, при этом уменьшается размер индекса и увеличивается размер тега.
<P>
<B>3. Какой блок кэш-памяти должен быть замещен при промахе?</B>
<P>
При возникновении промаха, контроллер кэш-памяти должен выбрать подлежащий замещению блок. Польза от использования организации с прямым отображением заключается в том, что аппаратные решения здесь наиболее простые. Выбирать просто нечего: на попадание проверяется только один блок и только этот блок может быть замещен. При полностью ассоциативной или множественно-ассоциативной организации кэш-памяти имеются несколько блоков, из которых надо выбрать кандидата в случае промаха. Как правило для замещения блоков применяются две основных стратегии: случайная и LRU.
<P>
В первом случае, чтобы иметь равномерное распределение, блоки-кандидаты выбираются случайно. В некоторых системах, чтобы получить воспроизводимое поведение, которое особенно полезно во время отладки аппаратуры, используют псевдослучайный алгоритм замещения.
<P>
Во втором случае, чтобы уменьшить вероятность выбрасывания информации, которая скоро может потребоваться, все обращения к блокам фиксируются. Заменяется тот блок, который не использовался дольше всех (LRU - Least-Recently Used).
<P>
Достоинство случайного способа заключается в том, что его проще реализовать в аппаратуре. Когда количество блоков для поддержания трассы увеличивается, алгоритм LRU становится все более дорогим и часто только приближенным. На рис. 7.2 показаны различия в долях промахов при использовании алгоритма замещения LRU и случайного алгоритма.
<table border=1>
<tr><td  colspan= 40>Ассоциативность:<td align=center colspan= 37>2-канальная<td align=center colspan= 37>4-канальная<td align=center colspan= 42>8-канальная
<tr><td  colspan= 40>Размер кэш-памяти<td  colspan= 37> LRU Random<td  colspan= 37> LRU Random<td  colspan= 42> LRU Random
<tr><td  colspan= 40>16 KB<td  colspan= 37> 5.18% 5.69%<td  colspan= 37> 4.67% 5.29%<td  colspan= 42> 4.39% 4.96%
<tr><td  colspan= 40>64 KB<td  colspan= 37> 1.88% 2.01%<td  colspan= 37> 1.54% 1.66%<td  colspan= 42> 1.39% 1.53%
<tr><td  colspan= 40>256 KB<td  colspan= 37> 1.15% 1.17%<td  colspan= 37> 1.13% 1.13%<td  colspan= 42> 1.12% 1.12%
</table>
<P ALIGN = center>
<I>Рис. 7.2. Сравнение долей промахов для алгоритма LRU и случайного алгоритма замещения
<br>
<P ALIGN = center>
при нескольких размерах кэша и разных ассоциативностях при размере блока 16 байт.</I>
<P>
<B>4. Что происходит во время записи?</B>
<P>
При обращениях к кэш-памяти на реальных программах преобладают обращения по чтению. Все обращения за командами являются обращениями по чтению и большинство команд не пишут в память. Обычно операции записи составляют менее 10% общего трафика памяти. Желание сделать общий случай более быстрым означает оптимизацию кэш-памяти для выполнения операций чтения, однако при реализации высокопроизводительной обработки данных нельзя пренебрегать и скоростью операций записи.
<P>
К счастью, общий случай является и более простым. Блок из кэш-памяти может быть прочитан в то же самое время, когда читается и сравнивается его тег. Таким образом, чтение блока начинается сразу как только становится доступным адрес блока. Если чтение происходит с попаданием, то блок немедленно направляется в процессор. Если же происходит промах, то от заранее считанного блока нет никакой пользы, правда нет и никакого вреда.
<P>
Однако при выполнении операции записи ситуация коренным образом меняется. Именно процессор определяет размер записи (обычно от 1 до 8 байтов) и только эта часть блока может быть изменена. В общем случае это подразумевает выполнение над блоком последовательности операций чтение-модификация-запись: чтение оригинала блока, модификацию его части и запись нового значения блока. Более того, модификация блока не может начинаться до тех пор, пока проверяется тег, чтобы убедиться в том, что обращение является попаданием. Поскольку проверка тегов не может выполняться параллельно с другой работой, то операции записи отнимают больше времени, чем операции чтения.
<P>
Очень часто организация кэш-памяти в разных машинах отличается именно стратегией выполнения записи. Когда выполняется запись в кэш-память имеются две базовые возможности:
<UL TYPE = disc>
<LI>сквозная запись (write through, store through) - информация записывается в два места: в блок кэш-памяти и в блок более низкого уровня памяти.
<LI>запись с обратным копированием (write back, copy back, store in) - информация записывается только в блок кэш-памяти. Модифицированный блок кэш-памяти записывается в основную память только когда он замещается. Для сокращения частоты копирования блоков при замещении обычно с каждым блоком кэш-памяти связывается так называемый бит модификации (dirty bit). Этот бит состояния показывает был ли модифицирован блок, находящийся в кэш-памяти. Если он не модифицировался, то обратное копирование отменяется, поскольку более низкий уровень содержит ту же самую информацию, что и кэш-память.
</UL>
<P>
Оба подхода к организации записи имеют свои преимущества и недостатки. При записи с обратным копированием операции записи выполняются со скоростью кэш-памяти, и несколько записей в один и тот же блок требуют только одной записи в память более низкого уровня. Поскольку в этом случае обращения к основной памяти происходят реже, вообще говоря требуется меньшая полоса пропускания памяти, что очень привлекательно для мультипроцессорных систем. При сквозной записи промахи по чтению не влияют на записи в более высокий уровень, и, кроме того, сквозная запись проще для реализации, чем запись с обратным копированием. Сквозная запись имеет также преимущество в том, что основная память имеет наиболее свежую копию данных. Это важно в мультипроцессорных системах, а также для организации ввода/вывода.
<P>
Когда процессор ожидает завершения записи при выполнении сквозной записи, то говорят, что он приостанавливается для записи (write stall). Общий прием минимизации остановов по записи связан с использованием буфера записи (write buffer), который позволяет процессору продолжить выполнение команд во время обновления содержимого памяти. Следует отметить, что остановы по записи могут возникать и при наличии буфера записи.
<P>
При промахе во время записи имеются две дополнительные возможности:
<UL TYPE = disc>
<LI>разместить запись в кэш-памяти (write allocate) (называется также выборкой при записи (fetch on write)). Блок загружается в кэш-память, вслед за чем выполняются действия аналогичные выполняющимся при выполнении записи с попаданием. Это похоже на промах при чтении.
<LI>не размещать запись в кэш-памяти (называется также записью в окружение (write around)). Блок модифицируется на более низком уровне и не загружается в кэш-память.
</UL>
<P>
Обычно в кэш-памяти, реализующей запись с обратным копированием, используется размещение записи в кэш-памяти (в надежде, что последующая запись в этот блок будет перехвачена), а в кэш-памяти со сквозной записью размещение записи в кэш-памяти часто не используется (поскольку последующая запись в этот блок все равно пойдет в память).
<P>
<B>Увеличение производительности кэш-памяти</B>
<P>
Формула для среднего времени доступа к памяти в системах с кэш-памятью выглядит следующим образом:
<P>
Среднее время доступа = Время обращения при попадании + Доля промахов x Потери при промахе
<P>
Эта формула наглядно показывает пути оптимизации работы кэш-памяти: сокращение доли промахов, сокращение потерь при промахе, а также сокращение времени обращения к кэш-памяти при попадании. Ниже на рис. 7.3 кратко представлены различные методы, которые используются в настоящее время для увеличения производительности кэш-памяти. Использование тех или иных методов определяется прежде всего целью разработки, при этом конструкторы современных компьютеров заботятся о том, чтобы система оказалась сбалансированной по всем параметрам.
<table border=1>
<tr><td align=center colspan= 52>Метод<td align=center colspan= 15>Доля<br>промахов<td align=center colspan= 16>Потери<br>при<br>промахе<td align=center colspan= 19>Время обраще-ния при<br>попадании<td align=center colspan= 16>Слож-ность аппаратуры<td align=center colspan= 37>Примечания
<tr><td align=left colspan= 52>Увеличение размера блока<td align=center colspan= 15>+<td align=center colspan= 16>-<td align=center colspan= 19><pre> </pre><td align=center colspan= 16>0<td  colspan= 37><pre> </pre>
<tr><td align=left colspan= 52>Повышение степени ассоциативности<td align=center colspan= 15>+<td align=center colspan= 16><pre> </pre><td align=center colspan= 19>-<td align=center colspan= 16>1<td  colspan= 37><pre> </pre>
<tr><td align=left colspan= 52>Кэш-память с <I>вспомогательным кэшем</I><td align=center colspan= 15>+<td align=center colspan= 16><pre> </pre><td align=center colspan= 19><pre> </pre><td align=center colspan= 16>2<td  colspan= 37><pre> </pre>
<tr><td align=left colspan= 52>Псевдоассоциативные кэши<td align=center colspan= 15>+<td align=center colspan= 16><pre> </pre><td align=center colspan= 19><pre> </pre><td align=center colspan= 16>2<td  colspan= 37><pre> </pre>
<tr><td align=left colspan= 52>Аппаратная предварительная выборка команд и данных<td align=center colspan= 15>+<td align=center colspan= 16><pre> </pre><td align=center colspan= 19><pre> </pre><td align=center colspan= 16>2<td align=left colspan= 37>Предварительная выборка данных затруднена
<tr><td align=left colspan= 52>Предварительная выборка под управлением компилятора<td align=center colspan= 15>+<td align=center colspan= 16><pre> </pre><td align=center colspan= 19><pre> </pre><td align=center colspan= 16>3<td align=left colspan= 37>Требует также неблокируемой кэш-памяти
<tr><td align=left colspan= 52>Специальные методы для уменьшения промахов<td align=center colspan= 15>+<td align=center colspan= 16><pre> </pre><td align=center colspan= 19><pre> </pre><td align=center colspan= 16>0<td  colspan= 37>Вопрос ПО
<tr><td align=left colspan= 52>Установка приоритетов промахов по чтению над записями<td align=center colspan= 15><pre> </pre><td align=center colspan= 16>+<td align=center colspan= 19><pre> </pre><td align=center colspan= 16>1<td align=left colspan= 37>Просто для однопроцессорных систем
<tr><td align=left colspan= 52>Использование подблоков<td align=center colspan= 15><pre> </pre><td align=center colspan= 16>+<td align=center colspan= 19>+<td align=center colspan= 16>1<td align=left colspan= 37>Сквозная запись +<br>подблок на 1 слово помогают записям
<tr><td align=left colspan= 52>Пересылка требуемого слова первым<td align=center colspan= 15><pre> </pre><td align=center colspan= 16>+<td align=center colspan= 19><pre> </pre><td align=center colspan= 16>2<td  colspan= 37><pre> </pre>
<tr><td align=left colspan= 52>Неблокируемые кэши<td align=center colspan= 15><pre> </pre><td align=center colspan= 16>+<td align=center colspan= 19><pre> </pre><td align=center colspan= 16>3<td  colspan= 37><pre> </pre>
<tr><td align=left colspan= 52>Кэши второго уровня<td align=center colspan= 15><pre> </pre><td align=center colspan= 16>+<td align=center colspan= 19><pre> </pre><td align=center colspan= 16>2<td  colspan= 37>Достаточно дорогое оборудование
<tr><td align=left colspan= 52>Простые кэши малого размера<td align=center colspan= 15>-<td align=center colspan= 16><pre> </pre><td align=center colspan= 19>+<td align=center colspan= 16>0<td  colspan= 37><pre> </pre>
<tr><td align=left colspan= 52>Обход преобразования адресов во время индексации кэш-памяти<td align=center colspan= 15><pre> </pre><td align=center colspan= 16><pre> </pre><td align=center colspan= 19>+<td align=center colspan= 16>2<td  colspan= 37><pre> </pre>
<tr><td align=left colspan= 52>Конвейеризация операций записи для быстрого попадания при записи<td align=center colspan= 15><pre> </pre><td align=center colspan= 16><pre> </pre><td align=center colspan= 19>+<td align=center colspan= 16>1<td  colspan= 37><pre> </pre>
</table>
<P ALIGN = center>
<I>Рис. 7.3. Обобщение методов оптимизации кэш-памяти</I>

<p><center><font size="-1">
[<a href="glava_7.htm">Предыдущая глава</a>] [<a href="contents.htm">Оглавление</a>] [<a href="glava_8_1.htm">Следующая глава</a>]
</font></center>
</body></html>
