<HTML>
<HEAD>
<TITLE>Современные высокопроизводительные компьютеры - Конвейерная и суперскалярная обработка</TITLE>
</head>

<body bgcolor="#FFFFFF" link="#950995" vlink="#650065" alink="#800000" text="#000000">

<H3><A NAME = "Устранение зависимостей по данным и механизмы динамического планирования">Устранение зависимостей по данным и механизмы динамического планирования</A></H3>
<P>
<B>Основная идея динамической оптимизации</B>
<P>
Главным ограничением методов конвейерной обработки, которые мы рассматривали ранее, является выдача для выполнения команд строго в порядке, предписанном программой: если выполнение какой-либо команды в конвейере приостанавливалось, следующие за ней команды также приостанавливались. Таким образом, при наличии зависимости между двумя близко расположенными в конвейере командами возникала приостановка обработки многих команд. Но если имеется несколько функциональных устройств, многие из них могут оказаться незагруженными. Если команда j зависит от длинной команды i, выполняющейся в конвейере, то все команды, следующие за командой j должны приостановиться до тех пор, пока команда i не завершится и не начнет выполняться команда j. Например, рассмотрим следующую последовательность команд:
<P>
DIVD F0,F2,F4
<P>
ADDD F10,F0,F8
<P>
SUBD F8,F8,F14
<P>
Команда SUBD не может выполняться из-за того, что зависимость между командами DIVD и ADDD привела к приостановке конвейера. Однако команда SUBD не имеет никаких зависимостей от команд в конвейере. Это ограничение производительности, которое может быть устранено снятием требования о выполнении команд в строгом порядке.
<P>
В рассмотренном нами конвейере структурные конфликты и конфликты по данным проверялись во время стадии декодирования команды (ID). Если команда могла нормально выполняться, она выдавалась с этой ступени конвейера в следующие. Чтобы позволить начать выполнение команды SUBD из предыдущего примера, необходимо разделить процесс выдачи на две части: проверку наличия структурных конфликтов и ожидание отсутствия конфликта по данным. Когда мы выдаем команду для выполнения, мы можем осуществлять проверку наличия структурных конфликтов; таким образом, мы все еще используем упорядоченную выдачу команд. Однако мы хотим начать выполнение команды как только станут доступными ее операнды. Таким образом, конвейер будет осуществлять неупорядоченное выполнение команд, которое означает и неупорядоченное завершение команд.
<P>
Неупорядоченное завершение команд создает основные трудности при обработке исключительных ситуаций. В рассматриваемых в данном разделе машинах с динамическим планированием потока команд прерывания будут неточными, поскольку команды могут завершиться до того, как выполнение более ранней выданной команды вызовет исключительную ситуацию. Таким образом, очень трудно повторить запуск после прерывания. Вместо того, чтобы рассматривать эти проблемы в данном разделе, мы обсудим возможные решения для реализации точных прерываний позже в контексте машин, использующих планирование по предположению.
<P>
Чтобы реализовать неупорядоченное выполнение команд, мы расщепляем ступень ID на две ступени:
<OL TYPE = 1>
<LI>Выдача - декодирование команд, проверка структурных конфликтов.
<LI>Чтение операндов - ожидание отсутствия конфликтов по данным и последующее чтение операндов.
</OL>
<P>
Затем, как и в рассмотренном нами конвейере, следует ступень EX. Поскольку выполнение команд ПТ может потребовать нескольких тактов в зависимости от типа операции, мы должны знать, когда команда начинает выполняться и когда заканчивается. Это позволяет нескольким командам выполняться в один и тот же момент времени. В дополнение к этим изменениям структуры конвейера мы изменим и структуру функциональных устройств, варьируя количество устройств, задержку операций и степень конвейеризации функциональных устройств так, чтобы лучше использовать эти методы конвейеризации.
<P>
<B>Динамическая оптимизация с централизованной схемой обнаружения конфликтов</B>
<P>
В конвейере с динамическим планированием выполнения команд все команды проходят через ступень выдачи строго в порядке, предписанном программой (упоря-доченная выдача). Однако они могут приостанавливаться и обходить друг друга на второй ступени (ступени чтения операндов) и тем самым поступать на ступени выполнения неупорядочено. Централизованная схема обнаружения конфликтов представляет собой метод, допускающий неупорядоченное выполнение команд при наличии достаточных ресурсов и отсутствии зависимостей по данным. Впервые подобная схема была применена в компьютере CDC 6600.
<P>
Прежде чем начать обсуждение возможности применения подобных схем, важно заметить, что конфликты типа WAR, отсутствующие в простых конвейерах, могут появиться при неупорядоченном выполнении команд. В ранее приведенном примере регистром результата для команды SUBD является регистр R8, который одновременно является источником операнда для команды ADDD. Поэтому здесь между командами ADDD и SUBD имеет место антизависимость: если конвейер выполнит команду SUBD раньше команды ADDD, он нарушит эту антизависимость. Этот конфликт WAR можно обойти, если выполнить два правила: (1) читать регистры только во время стадии чтения операндов и (2) поставить в очередь операцию ADDD вместе с копией ее операндов. Чтобы избежать нарушений зависимостей по выходу конфликты типа WAW (например, это могло произойти, если бы регистром результата команды SUBD была бы регистр F10) все еще должны обнаруживаться. Конфликты типа WAW могут быть устранены с помощью приостановки выдачи команды, регистр результата которой совпадает с уже используемым в конвейере.
<P>
Задачей централизованной схемы обнаружения конфликтов является поддержание выполнения команд со скоростью одна команда за такт (при отсутствии структурных конфликтов) посредством как можно более раннего начала выполнения команд. Таким образом, когда команда в начале очереди приостанавливается, другие команды могут выдаваться и выполняться, если они не зависят от уже выполняющейся или приостановленной команды. Централизованная схема несет полную ответственность за выдачу и выполнение команд, включая обнаружение конфликтов. Подобное неупорядоченное выполнение команд требует одновременного нахождения нескольких команд на стадии выполнения. Этого можно достигнуть двумя способами: реализацией в процессоре либо множества неконвейерных функциональных устройств, либо путем конвейеризации всех функциональных устройств. Обе эти возможности по сути эквивалентны с точки зрения организации управления. Поэтому предположим, что в машине имеется несколько неконвейерных функциональных устройств.
<P>
Машина CDC 6600 имела 16 отдельных функциональных устройств (4 устройства для операций с плавающей точкой, 5 устройств для организации обращений к основной памяти и 7 устройств для целочисленных операций). В нашем случае централизованная схема обнаружения конфликтов имеет смысл только для устройства плавающей точки. Предположим, что имеются два умножителя, один сложитель, одно устройство деления и одно целочисленное устройство для всех операций обращения к памяти, переходов и целочисленных операций. Хотя устройств в этом примере гораздо меньше, чем в CDC 6600, он достаточно мощный для демонстрации основных принципов работы. Поскольку как наша машина, так и CDC 6600 являются машинами с операциями регистр-регистр (операциями загрузки/записи), в обеих машинах методика практически одинаковая. На рис. 6.3 показана подобная машина.
<P>
<CENTER><IMG SRC = "img00012.gif" BORDER = 1 ></CENTER>

<P ALIGN = center>
<I>Рис. 6.3. Централизованная схема управления</I>
<P>
Каждая команда проходит через централизованную схему обнаружения конфликтов, которая определяет зависимости по данным; этот шаг соответствует стадии выдачи команд и заменяет часть стадии ID в нашем конвейере. Эти зависимости определяют затем моменты времени, когда команда может читать свои операнды и начинать выполнение операции. Если централизованная схема решает, что команда не может немедленно выполняться, она следит за всеми изменениями в аппаратуре и решает, когда команда сможет выполняться. Эта же централизованная схема определяет также когда команда может записать результат в свой регистр результата. Таким образом, все схемы обнаружения и разрешения конфликтов здесь выполняются устройством центрального управления.
<P>
Каждая команда проходит четыре стадии своего выполнения. (Поскольку в данный момент мы интересуемся операциями плавающей точки, мы не рассматриваем стадию обращения к памяти). Рассмотрим эти стадии сначала неформально, а затем детально рассмотрим как централизованная схема поддерживает необходимую информацию, которая определяет обработку при переходе с одной стадии на другую. Следующие четыре стадии заменяют стадии ID, EX и WB в стандартном конвейере:
<OL TYPE = 1>
<LI><I>Выдача.</I> Если функциональное устройство, необходимое для выполнения команды, свободно и никакая другая выполняющаяся команда не использует тот же самый регистр результата, централизованная схема выдает команду в функциональное устройство и обновляет свою внутреннюю структуру данных. Поскольку никакое другое работающее функциональное устройство не может записать результат в регистр результата нашей команды, мы гарантируем, что конфликты типа WAW не могут появляться. Если существует структурный конфликт или конфликт типа WAW, выдача команды блокируется и никакие следующие команды не будут выдаваться на выполнение до тех пор, пока эти конфликты существуют. Эта стадия заменяет часть стадии ID в нашем конвейере.
<LI><I>Чтение операндов.</I> Централизованная схема следит за возможностью выборки источников операндов для соответствующей команды. Операнд-источник доступен, если отсутствует выполняющаяся команда, которая записывает результат в этот регистр или если в данный момент времени в регистр, содержащий операнд, выполняется запись из работающего функционального устройства. Если операнды-источники доступны, централизованная схема сообщает функциональному устройству о необходимости чтения операндов из регистров и начале выполнения операции. Централизованная схема разрешает конфликты RAW на этой стадии динамически и команды могут посылаться для выполнения не в порядке, предписанном программой. Эта стадия, совместно со стадией выдачи, завершает работу стадии ID простого конвейера.
<LI><I>Выполнение.</I> Функциональное устройство начинает выполнение операции после получения операндов. Когда результат готов оно уведомляет централизованную схему управления о том, что оно завершило выполнение операции. Эта стадия заменяет стадию EX и занимает несколько тактов в рассмотренном ранее конвейере.
<LI><I>Запись результата.</I> Когда централизованная схема управления узнает о том, что функциональное устройство завершило выполнение операции, она проверяет существование конфликта типа WAR. Конфликт типа WAR существует, если имеется последовательность команд, аналогичная представленной в нашем примере с командами ADDF и SUBF. В том примере мы имели следующую последовательность команд:
</OL>
<P>
DIVF F0,F2,F4
<P>
ADDF F10,F0,F8
<P>
SUBF F8,F8,F14
<P>
Команда ADDF имеет операнд-источник F8, который является тем же самым регистром, что и регистр результата команды SUBF. Но в действительности команда ADDF зависит от предыдущей команды. Централизованная схема управления будет блокировать выдачу команды SUBF до тех пор, пока команда ADDF не прочитает свои операнды. Тогда в общем случае завершающейся команде не разрешается записывать свои результаты если:
<UL TYPE = disc>
<LI>имеется команда, которая не прочитала свои операнды,
<LI>один из операндов является регистром результата завершающейся команды.
</UL>
<P>
Если этот конфликт типа WAR не существует, централизованная схема управления сообщает функциональному устройству о необходимости записи результата в регистр назначения. Эта стадия заменяет стадию WB в простом конвейере.
<P>
Основываясь на своей собственной структуре данных, централизованная схема управления управляет продвижением команды с одной ступени на другую взаимодействуя с функциональными устройствами. Но имеется небольшое усложнение: в регистровом файле имеется только ограниченное число магистралей для операндов-источников и магистралей для записи результата. Централизованная схема управления должна гарантировать, что количество функциональных устройств, которым разрешено продолжать работу на ступенях 2 и 4 не превышает числа доступных шин. Мы не будем вдаваться в дальнейшие подробности и упомянем лишь, что CDC 6600 решала эту проблему путем объединения 16 функциональных устройств друг с другом в четыре группы и поддержки для каждой группы устройств набора шин, называемых магистралями данных (data trunks). Только одно устройство в группе могло читать операнды или записывать свой результат в течение одного такта.
<P>
Общая структура регистров состояния устройства централизованного управления показана на рисунке 6.4. Она состоит из 3-х частей:
<OL TYPE = 1>
<LI>Состояние команды - показывает каждый из четырех этапов выполнения команды.
<LI>Состояние функциональных устройств - имеются 9 полей, описывающих состояние каждого функционального устройства:
</OL>
Занятость - показывает, занято устройство или свободно
Op - выполняемая в устройстве операция
F<SUB>i </SUB>- регистр результата
F<SUB>j</SUB>, F<SUB>k</SUB> - регистры-источники операндов
Q<SUB>j</SUB>, Q<SUB>k</SUB> - функциональные устройства, вырабатывающие результат для записи в регистры F<SUB>j</SUB>, F<SUB>k</SUB>
R<SUB>j</SUB>, R<SUB>k</SUB> - признаки готовности операндов в регистрах F<SUB>j</SUB>, F<SUB>k</SUB>
<OL TYPE = 1>
<LI>Состояние регистров результата - показывает функциональное устройство, которое будет записывать в каждый из регистров. Это поле устанавливается в ноль, если отсутствуют команды, записывающие результат в данный регистр.
</OL>
<P>
Интересным вопросом является стоимость и преимущества централизованного управления. Разработчики CDC 6600 оценивают улучшение производительности для программ на Фортране в 1.7 раза, а для вручную запрограммированных на языке ассемблера программ в 2.5 раза. Однако эти оценки делались в то время, когда отсутствовали программные средства планирования загрузки конвейера, полупроводниковая основная память и кэш-память (с малым временем доступа). Централизованная схема управления CDC 6600 имела примерно столько же логических схем, что и одно из функциональных устройств, что на удивление мало. Основная стоимость определялась большим количеством шин (магистралей) - примерно в четыре раза больше по сравнению с машиной, которая выполняла бы команды в строгом порядке, заданном программой.
<P>
Централизованная схема управления не обрабатывает несколько ситуаций. Например, когда команда записывает свой результат, зависимая команда в конвейере должна дожидаться разрешения обращения к регистровому файлу, поскольку все результаты всегда записываются в регистровый файл и никогда не используется методика &quot;ускоренной пересылки&quot;. Это увеличивает задержку и ограничивает возможность инициирования нескольких команд, ожидающих результата. Что касается CDC 6600, то конфликты типа WAW являются очень редкими, так что приостановки, которые они вызывают, возможно не являются существенными. Однако в следующем разделе мы увидим, что динамическое планирование дает возможность совмещенного выполнения нескольких итераций цикла. Чтобы это делать эффективно, требуется схема обработки конфликтов типа WAW, которые вероятно увеличиваются по частоте при совмещении выполнения нескольких итераций.
<table border=1>
<tr><td align=center colspan= 158><B>Состояние команд</B>
<tr><td align=center colspan= 41><B>Команда</B><td align=center colspan= 28><B>Выдача</B><td align=center colspan= 32><B>Чтение<br>операндов</B><td align=center colspan= 30><B>Завершение выполнения</B><td align=center colspan= 27><B>Запись<br>результата</B>
<tr><td  colspan= 16>LD<td  colspan= 25>F6,34(R2)<td align=center colspan= 28>(<td align=center colspan= 32>(<td align=center colspan= 30>(<td align=center colspan= 27>(
<tr><td  colspan= 16>LD<td  colspan= 25>F2,45(R3)<td align=center colspan= 28>(<td align=center colspan= 32>(<td align=center colspan= 30>(<td  colspan= 27><pre> </pre>
<tr><td  colspan= 16>MULTD<td  colspan= 25>F0,F2,F4<td align=center colspan= 28>(<td  colspan= 32><pre> </pre><td  colspan= 30><pre> </pre><td  colspan= 27><pre> </pre>
<tr><td  colspan= 16>SUBD<td  colspan= 25>F8,F6,F2<td align=center colspan= 28>(<td  colspan= 32><pre> </pre><td  colspan= 30><pre> </pre><td  colspan= 27><pre> </pre>
<tr><td  colspan= 16>DIVD<td  colspan= 25>F10,F0,F6<td align=center colspan= 28>(<td  colspan= 32><pre> </pre><td  colspan= 30><pre> </pre><td  colspan= 27><pre> </pre>
<tr><td  colspan= 16>ADD<td  colspan= 25>F6,F8,F2<td  colspan= 28><pre> </pre><td  colspan= 32><pre> </pre><td  colspan= 30><pre> </pre><td  colspan= 27><pre> </pre>
<tr><td  colspan= 16><pre> </pre><td  colspan= 25><pre> </pre><td  colspan= 28><pre> </pre><td  colspan= 32><pre> </pre><td  colspan= 30><pre> </pre><td  colspan= 27><pre> </pre>
<tr><td align=center colspan= 158><B>Состояние функциональных устройств</B>
<tr><td  colspan= 16><B>Имя</B><td align=center colspan= 22><B>Занятость</B><td align=center colspan= 16><B>Op</B><td align=center colspan= 16><B>F<SUB>i</B></SUB><td align=center colspan= 16><B>F<SUB>j</B></SUB><td align=center colspan= 16><B>F<SUB>k</B></SUB><td align=center colspan= 13><B>Q<SUB>j</B></SUB><td align=center colspan= 16><B>Q<SUB>k</B></SUB><td align=center colspan= 17><B>R<SUB>j</B></SUB><td align=center colspan= 10><B>R<SUB>k</B></SUB>
<tr><td  colspan= 16>Integer<td align=center colspan= 22>Да<td align=center colspan= 16>Load<td align=center colspan= 16>F2<td align=center colspan= 16>R3<td align=center colspan= 16><pre> </pre><td align=center colspan= 13><pre> </pre><td align=center colspan= 16><pre> </pre><td align=center colspan= 17><pre> </pre><td align=center colspan= 10><pre> </pre>
<tr><td  colspan= 16>Mult1<td align=center colspan= 22>Да<td align=center colspan= 16>Mult<td align=center colspan= 16>F0<td align=center colspan= 16>F2<td align=center colspan= 16>F4<td align=center colspan= 13><pre> </pre><td align=center colspan= 16><pre> </pre><td align=center colspan= 17>Нет<td align=center colspan= 10>Да
<tr><td  colspan= 16>Mult2<td align=center colspan= 22>Нет<td align=center colspan= 16><pre> </pre><td align=center colspan= 16><pre> </pre><td align=center colspan= 16><pre> </pre><td align=center colspan= 16><pre> </pre><td align=center colspan= 13><pre> </pre><td align=center colspan= 16><pre> </pre><td align=center colspan= 17><pre> </pre><td align=center colspan= 10><pre> </pre>
<tr><td  colspan= 16>Add<td align=center colspan= 22>Да<td align=center colspan= 16>Sub<td align=center colspan= 16>F8<td align=center colspan= 16>F6<td align=center colspan= 16>F2<td align=center colspan= 13><pre> </pre><td align=center colspan= 16>Integer<td align=center colspan= 17>Да<td align=center colspan= 10>Нет
<tr><td  colspan= 16>Divide<td align=center colspan= 22>Да<td align=center colspan= 16>Div<td align=center colspan= 16>F10<td align=center colspan= 16>F0<td align=center colspan= 16>F6<td align=center colspan= 13>Mult1<td align=center colspan= 16><pre> </pre><td align=center colspan= 17>Нет<td align=center colspan= 10>Да
<tr><td  colspan= 16><pre> </pre><td align=center colspan= 22><pre> </pre><td align=center colspan= 16><pre> </pre><td align=center colspan= 16><pre> </pre><td align=center colspan= 16><pre> </pre><td align=center colspan= 16><pre> </pre><td align=center colspan= 13><pre> </pre><td align=center colspan= 16><pre> </pre><td align=center colspan= 17><pre> </pre><td align=center colspan= 10><pre> </pre>
<tr><td align=center colspan= 158><B>Состояние регистра результата</B>
<tr><td align=center colspan= 16><pre> </pre><td align=center colspan= 22><B>F0</B><td align=center colspan= 15><B>F2</B><td align=center colspan= 17><B>F4</B><td align=center colspan= 15><B>F6</B><td align=center colspan= 15><B>F8</B><td align=center colspan= 15><B>F10</B><td align=center colspan= 20><B>F12</B><td align=center colspan= 12><B>. . .</B><td align=center colspan= 11><B>F30</B>
<tr><td align=center colspan= 16>FU<td align=center colspan= 22>Mult1<td align=center colspan= 15>Integer<td align=center colspan= 17><pre> </pre><td align=center colspan= 15><pre> </pre><td align=center colspan= 15>Add<td  colspan= 15>Divide<td align=center colspan= 20><pre> </pre><td align=center colspan= 12><pre> </pre><td align=center colspan= 11><pre> </pre>
</table>
<P ALIGN = center>
<I>Рис. 6.4. Регистры состояния централизованной схемы управления</I>
<P>
<B>Другой подход к динамическому планированию - алгоритм Томасуло</B>
<P>
Другой подход к параллельному выполнению команд при наличии конфликтов был использован в устройстве плавающей точки в машине IBM 360/91. Эта схема приписывается Р. Томасуло и названа его именем. Разработка IBM 360/91 была завершена спустя три года после выпуска CDC 6600, прежде чем кэш-память появилась в коммерческих машинах. Задачей IBM было достижение высокой производительности на операциях с плавающей точкой, используя набор команд и компиляторы, разработанные для всего семейства 360, а не только для приложений с интенсивным использованием плавающей точки. Архитектура 360 предусматривала только четыре регистра плавающей точки двойной точности, что ограничивало эффективность планирования кода компилятором. Этот факт был другой мотивацией подхода Томасуло. Наконец, машина IBM 360/91 имела большое время обращения к памяти и большие задержки выполнения операций плавающей точки, преодолеть которые и был призван разработанный Томасуло алгоритм. В конце раздела мы увидим, что алгоритм Томасуло может также поддерживать совмещенное выполнение нескольких итераций цикла.
<P>
Мы поясним этот алгоритма на примере устройства ПТ. Основное различие между нашим конвейером ПТ и конвейером машины IBM/360 заключается в наличии в последней машине команд типа регистр-память. Поскольку алгоритм Томасуло использует функциональное устройство загрузки, не требуется значительных изменений, чтобы добавить режимы адресации регистр-память; основное добавление - другая шина. IBM 360/91 имела также конвейерные функциональные устройства, а не несколько функциональных устройств. Единственное отличие между ними заключается в том, что конвейерное функциональное устройство может начинать выполнение только одной операции в каждом такте. Поскольку реально отсутствуют фундаментальные отличия, мы описываем алгоритм, как если бы имели место несколько функциональных устройств. IBM 360/91 могла выполнять одновременно три операции сложения ПТ и две операции умножения ПТ. Кроме того, в процессе выполнения могли находиться до 6 операций загрузки ПТ, или обращений к памяти, и до трех операций записи ПТ. Для реализации этих функций использовались буфера данных загрузки и буфера данных записи. Хотя мы не будем обсуждать устройства загрузки и записи, необходимо добавить буфера для операндов.
<P>
Схема Томасуло имеет много общего со схемой централизованного управления CDC 6600, однако имеются и существенные отличия. Во-первых, обнаружение конфликтов и управление выполнением являются распределенными - станции резервирования (reservation stations) в каждом функциональном устройстве определяют, когда команда может начать выполняться в данном функциональном устройстве. В CDC 6600 эта функция централизована. Во-вторых, результаты операций посылаются прямо в функциональные устройства, а не проходят через регистры. В IBM 360/91 имеется общая шина результатов операций (которая называется общей шиной данных (common data bus - CDB)), которая позволяет производить одновременную загрузку всех устройств, ожидающих операнда. CDC 6600 записывает результаты в регистры, за которые ожидающие функциональные устройства могут соперничать. Кроме того, CDC 6600 имеет несколько шин завершения операций (две в устройстве ПТ), а IBM 360/91 - только одну.
<P>
На рис. 6.5 представлена основная структура устройства ПТ на базе алгоритма Томасуло. Никаких таблиц управления выполнением не показано. Станции резервирования хранят команды, которые выданы и ожидают выполнения в соответствующем функциональном устройстве, а также информацию, требующуюся для управления командой, когда ее выполнение началось в функциональном устройстве. Буфера загрузки и записи хранят данные поступающие из памяти и записываемые в память. Регистры ПТ соединены с функциональными устройствами парой шин и одной шиной с буферами записи. Все результаты из функциональных устройств и из памяти посылаются на общую шину данных, которая связана со входами всех устройств за исключением буфера загрузки. Все буфера и станции резервирования имеют поля тегов, используемых для управления конфликтами.
<P>
Прежде чем описывать детали станций резервирования и алгоритм, рассмотрим все стадии выполнения команды. В отличие от централизованной схемы управления, имеется всего три стадии:
<OL TYPE = 1>
<LI>Выдача - Берет команду из очереди команд ПТ. Если операция является операцией ПТ, выдает ее при наличии свободной станции резервирования и посылает операнды на станцию резервирования, если они находятся в регистрах. Если операция является операцией загрузки или записи, она может выдаваться при наличии свободного буфера. При отсутствии свободной станции резервирования или свободного буфера возникает структурный конфликт и команда приостанавливается до тех пор, пока не освободится станция резервирования или буфер.
<LI>Выполнение - Если один или более операндов команды не доступны по каким либо причинам, контролируется состояние CDB и ожидается завершение вычисления значений нужного регистра. На этой стадии выполняется контроль конфликтов типа RAW. Когда оба операнда доступны, выполняется операция.
<LI>Запись результата - Когда становится доступным результат, он записывается на CDB и оттуда в регистры и любое функциональное устройство, ожидающее этот результат.
</OL>
<P>
Хотя эти шаги в основном похожи на аналогичные шаги в централизованной схеме управления, имеются три важных отличия. Во-первых, отсутствует контроль конфликтов типа WAW и WAR - они устраняются как побочный эффект алгоритма. Во-вторых, для трансляции результатов используется CDB, а не схема ожидания готовности регистров. В-третьих, устройства загрузки и записи рассматриваются как основные функциональные устройства.
<P>
Структуры данных, используемые для обнаружения и устранения конфликтов, связаны со станциями резервирования, регистровым файлом и буферами загрузки и записи. Хотя с разными объектами связана разная информация, все устройства, за исключением буферов загрузки, содержат в каждой строке поле тега. Это поле тега представляет собой четырехбитовое значение, которое обозначает одну из пяти станций резервирования или один из шести буферов загрузки. Поле тега используется для описания того, какое функциональное устройства будет поставлять результат, нужный в качестве источника операнда. Неиспользуемые значения, такие как ноль, показывают что операнд уже доступен. Важно помнить, что теги в схеме Томасуло ссылаются на буфера или устройства, которые будут поставлять результат; когда команда выдается в станцию резервирования номера регистров исключаются из рассмотрения.
<P ALIGN = center>
<CENTER><IMG SRC = "img00013.gif" BORDER = 1 ></CENTER>

<P ALIGN = center>
<I>Рис. 6.5. Структура устройства ПТ на основе алгоритма Томасуло</I>
<P>
Каждая станция резервирования содержит шесть полей:
<UL TYPE = disc>
<LI>O<SUB>p</SUB> - Операция, которая должна выполняться над источниками операндов S<SUB>1</SUB> и S<SUB>2</SUB>;
<LI>Q<SUB>j</SUB>,Q<SUB>k</SUB> - станции резервирования, которые будут вырабатывать соответствующий операнд-источник; нулевое значение показывает, что операнд-источник уже доступен в V<SUB>j</SUB> или V<SUB>k</SUB>, или не является обязательным. IBM 360/91 называет их SINKunit и SOURCEunit.
<LI>V<SUB>j</SUB>,V<SUB>k</SUB> - значение операндов-источников. Они называются SINK и SOURCE в IBM 360/91. Заметим, что для каждого операнда являются действительными только одно из полей либо поле V, либо поле Q.
<LI>Занято - Показывает, что данная станция резервирования и ее соответствующее функциональное устройство заняты.
</UL>
<P>
Регистровый файл и буфер записи имеют поле Q<SUB>i</SUB>:
<UL TYPE = disc>
<LI>Q<SUB>i</SUB> - номер функционального устройства, которое будет вырабатывать значение, которое надо записать в регистр или память. Если значение Q<SUB>i</SUB> равно нулю, то это означает, что ни одна текущая активная команда не вычисляет результат для данного регистра или буфера. Для регистра это означает, что значение определяется содержимым регистра.
</UL>
<P>
В каждом из буферов загрузки и записи требуется поле занятости, показывающее когда соответствующий буфер становится доступным благодаря завершению загрузки или записи, назначенных на этот буфер. Буфер записи имеет также поле V для хранения значения, которое должно быть записано в память.
<P>
Прежде, чем мы исследуем алгоритм в деталях, давайте посмотрим как выглядят системные таблицы для следующей последовательности команд:
<P>
1. LF F6,34(R2)
<P>
2. LF F2,45(R3)
<P>
3. MULTD F0,F2,F4
<P>
4. SUBD F8,F6,F2
<P>
5. DIVD F10,F0,F6
<P>
6. ADDD F6,F8,F2
<P>
Рис. 6.6 описывает станции резервирования, буфера загрузки и записи и регистровые теги. К именам add, mult и load добавлены номера, стоящие за тегами для этой станции резервирования - Add1 является тегом для результата из первого устройства сложения. Состояние каждой операции, которая выдана для выполнения, хранится в станции резервирования.
<table border=1>
<tr><td align=center colspan= 158><B>Состояние команд</B>
<tr><td  colspan= 51><B>Команда</B><td align=center colspan= 38><B>Выдача</B><td align=center colspan= 36><B>Выполнение</B><td align=center colspan= 33><B>Запись результата</B>
<tr><td  colspan= 16>LD<td  colspan= 35>F6,34(R2)<td align=center colspan= 38>(<td align=center colspan= 36>(<td align=center colspan= 33>(+
<tr><td  colspan= 16>LD<td  colspan= 35>F2,45(R3)<td align=center colspan= 38>(<td align=center colspan= 36>(<td align=center colspan= 33><pre> </pre>
<tr><td  colspan= 16>MULTD<td  colspan= 35>F0,F2,F4<td align=center colspan= 38>(<td align=center colspan= 36><pre> </pre><td align=center colspan= 33><pre> </pre>
<tr><td  colspan= 16>SUBD<td  colspan= 35>F8,F6,F2<td align=center colspan= 38>(<td align=center colspan= 36><pre> </pre><td align=center colspan= 33><pre> </pre>
<tr><td  colspan= 16>DIVD<td  colspan= 35>F10,F0,F6<td align=center colspan= 38>(<td align=center colspan= 36><pre> </pre><td align=center colspan= 33><pre> </pre>
<tr><td  colspan= 16>ADDD<td  colspan= 35>F6,F8,F2<td align=center colspan= 38>(<td align=center colspan= 36><pre> </pre><td align=center colspan= 33><pre> </pre>
<tr><td  colspan= 16><pre> </pre><td  colspan= 35><pre> </pre><td align=center colspan= 38><pre> </pre><td align=center colspan= 36><pre> </pre><td align=center colspan= 33><pre> </pre>
<tr><td align=center colspan= 158><B>Станции резервирования</B>
<tr><td align=center colspan= 16><B>Имя</B><td align=center colspan= 20><B>Занятость</B><td align=center colspan= 15><B>Op</B><td align=center colspan= 37><B>V<SUB>j</B></SUB><td align=center colspan= 37><B>V<SUB>k</B></SUB><td align=center colspan= 17><B>Q<SUB>j</B></SUB><td align=center colspan= 16><B>Q<SUB>k</B></SUB>
<tr><td align=center colspan= 16>Add1<td align=center colspan= 20>Да<td align=center colspan= 15>SUB<td align=center colspan= 37>Mem[34+Regs[R2]]<td align=center colspan= 37><pre> </pre><td align=center colspan= 17><pre> </pre><td align=center colspan= 16>Load2
<tr><td align=center colspan= 16>Add2<td align=center colspan= 20>Да<td align=center colspan= 15>ADD<td align=center colspan= 37><pre> </pre><td align=center colspan= 37><pre> </pre><td align=center colspan= 17>Add1<td align=center colspan= 16>Load2
<tr><td align=center colspan= 16>Add3<td align=center colspan= 20>Нет<td align=center colspan= 15><pre> </pre><td align=center colspan= 37><pre> </pre><td align=center colspan= 37><pre> </pre><td align=center colspan= 17><pre> </pre><td align=center colspan= 16><pre> </pre>
<tr><td align=center colspan= 16>Mult1<td align=center colspan= 20>Да<td align=center colspan= 15>MULT<td align=center colspan= 37><pre> </pre><td align=center colspan= 37>Regs[F4]<td align=center colspan= 17>Load2<td align=center colspan= 16><pre> </pre>
<tr><td align=center colspan= 16>Mult2<td align=center colspan= 20>Да<td align=center colspan= 15>DIV<td align=center colspan= 37><pre> </pre><td align=center colspan= 37>Mem[34+Regs[R2]]<td align=center colspan= 17>Mult1<td align=center colspan= 16><pre> </pre>
<tr><td align=center colspan= 16><pre> </pre><td align=center colspan= 20><pre> </pre><td align=center colspan= 15><pre> </pre><td align=center colspan= 37><pre> </pre><td align=center colspan= 37><pre> </pre><td align=center colspan= 17><pre> </pre><td align=center colspan= 16><pre> </pre>
<tr><td align=center colspan= 158><B>Состояние регистров</B>
<tr><td align=center colspan= 16><B>Поле</B><td align=center colspan= 16><B>F0</B><td align=center colspan= 16><B>F2</B><td align=center colspan= 16><B>F4</B><td align=center colspan= 16><B>F6</B><td align=center colspan= 16><B>F8</B><td align=center colspan= 16><B>F10</B><td align=center colspan= 16><B>F12</B><td align=center colspan= 16><B>. . .</B><td align=center colspan= 14><B>F30</B>
<tr><td align=center colspan= 16>Qi<td align=center colspan= 16>Mult1<td align=center colspan= 16>Load2<td align=center colspan= 16><pre> </pre><td align=center colspan= 16>Add2<td align=center colspan= 16>Add1<td align=center colspan= 16>Mult2<td align=center colspan= 16><pre> </pre><td align=center colspan= 16><pre> </pre><td align=center colspan= 14><pre> </pre>
</table>
<P ALIGN = center>
<I>Рис. 6.6. Теги станций резервирования и регистров</I>
<P>
Имеются два важных отличия от централизованной схемы управления, которые заметны в этих таблицах. Во-первых, значение операнда хранится в станции резервирования в одном из полей V как только оно становится доступным; оно не считывается из регистрового файла во время выдачи команды. Во-вторых, команда ADDD выдана для выполнения. Ее выдача была заблокирована в централизованной схеме управления из-за наличия структурного конфликта.
<P>
Большие преимущества схемы Томасуло заключаются в (1) распределении логики обнаружения конфликтов, и (2) устранение приостановок, связанных с конфликтами типа WAW и WAR. Первое преимущество возникает из-за наличия распределенных станций резервирования и использования CDB. Если несколько команд ожидают один и тот же результат и каждая команда уже имеет свой другой операнд, то команды могут выдаваться одновременно посредством трансляции по CDB. В централизованной схеме управления ожидающие команды должны читать свои операнды из регистров когда станут доступными регистровые шины.
<P>
Конфликты типа WAW и WAR устраняются путем переименования регистров используя станции резервирования. Например, в нашей кодовой последовательности на рис. 6.6 мы выдали на выполнение как команду DIVD, так и команду ADDD, даже хотя имелся конфликт типа WAR по регистру F6. Конфликт устраняется одним из двух способов. Если команда, поставляющая значение для команды DIVD, завершилась, тогда V<SUB>k</SUB> будет хранить результат, позволяя DIVD выполняться независимо от команды ADDD. С другой стороны, если выполнение команды LF не завершилось, то Q<SUB>k</SUB> будет указывать на LOAD1 и команда DIVD будет независимой от ADDD. Таким образом, в любом случае команда ADDD может быть выдана и начать выполняться. Любое использование результата команды MULTD будет указывать на станцию резервирования, позволяя ADDD завершить и записать свое значение в регистры без воздействия DIVD. Вскоре мы увидим пример устранения конфликта типа WAW.
<P>
Чтобы понять полную мощность устранения конфликтов типа WAW и WAR посредством динамического переименования регистров мы должны рассмотреть цикл. Рассмотрим следующую простую последовательность команд для умножения элементов вектора на скалярную величину, находящуюся в регистре F2:
<P>
Loop: LD F0,0(R1)
<P>
MULTD F4,F0,F2
<P>
SD 0(R1),F4
<P>
SUBI R1,R1,#8
<P>
BNEZ R1,Loop ; условный переход при R1 /=0
<P>
Со стратегией выполняемого перехода использование станций резервирования позволит сразу же продолжить выполнение нескольких итераций этого цикла. Это преимущество дается без статического разворачивания цикла программными средствами: в действительности цикл разворачивается динамически аппаратурой. В архитектуре 360 наличие всего 4 регистров ПТ сильно ограничивало бы использование статического разворачивания цикла. (Вскоре мы увидим, что при статическом разворачивании и планировании выполнения цикла для обхода взаимных блокировок требуется значительно большее число регистров). Алгоритм Томасуло поддерживает выполнение с перекрытием нескольких копий одного и того же цикла при наличии лишь небольшого числа регистров, используемых программой.
<P>
Давайте предположим, что мы выдали для выполнения все команды двух последовательных итераций цикла, но еще не завершилось выполнение ни одной операции загрузки/записи в память. Станции резервирования, таблицы состояния регистров и буфера загрузки/записи в этой точке показаны на<B> </B>рис. 6.7. (Здесь операции целочисленного АЛУ игнорируются и предполагается, что условный переход был спрогнозирован как выполняемый). Когда система достигла такого состояния могут поддерживаться две копии цикла с CPI близким к единице при условии, что операции умножения могут завершиться за четыре такта. Если мы игнорируем накладные расходы цикла, которые не снижены в этой схеме, достигнутый уровень производительности будет соответствовать тому, который мы могли бы достигнуть посредством статического разворачивания и планирования цикла компилятором при условии наличия достаточного числа регистров.
<P>
В этом примере показан дополнительный элемент, который является важным для того, чтобы алгоритм Томасуло работал. Команда загрузки из второй итерации цикла может легко закончиться раньше команды записи из первой итерации, хотя нормальный последовательный порядок отличается. Загрузка и запись могут надежно (безопасно) выполняться в различном порядке при условии, что загрузка и запись обращаются к разным адресам. Это контролируется путем проверки адресов в буфере записи каждый раз при выдаче команды загрузки. Если адрес команды загрузки соответствует одному из адресов в буфере записи мы должны остановиться и подождать до тех пор, пока буфер записи не получит требуемое значение; затем мы можем к нему обращаться или выбирать значение из памяти. Это динамическое сравнение адресов является альтернативой технике, которая может использоваться компилятором при перестановке команд загрузки и записи.
<table border=1>
<tr><td align=center colspan= 160><B>Состояние команд</B>
<tr><td align=center colspan= 41><B>Команда</B><td align=center colspan= 27><B>Номер<br>итерации</B><td align=center colspan= 32><B>Выдача</B><td align=center colspan= 24><B>Выполнение</B><td align=center colspan= 36><B>Запись<br>результата</B>
<tr><td  colspan= 16>LD<td  colspan= 25>F0,0(R1)<td align=center colspan= 27>1<td align=center colspan= 32>(<td align=center colspan= 24>(<td align=center colspan= 36><pre> </pre>
<tr><td  colspan= 16>MULTD<td  colspan= 25>F4,F0,F2<td align=center colspan= 27>1<td align=center colspan= 32>(<td align=center colspan= 24><pre> </pre><td  colspan= 36><pre> </pre>
<tr><td  colspan= 16>SD<td  colspan= 25>0(R1),F4<td align=center colspan= 27>1<td align=center colspan= 32>(<td  colspan= 24><pre> </pre><td  colspan= 36><pre> </pre>
<tr><td  colspan= 16>LD<td  colspan= 25>F0,0(R1)<td align=center colspan= 27>2<td align=center colspan= 32>(<td align=center colspan= 24>(<td  colspan= 36><pre> </pre>
<tr><td  colspan= 16>MULTD <td  colspan= 25>F4,F0,F2<td align=center colspan= 27>2<td align=center colspan= 32>(<td  colspan= 24><pre> </pre><td  colspan= 36><pre> </pre>
<tr><td  colspan= 16>SD<td  colspan= 25>0(R1),F4<td align=center colspan= 27>2<td align=center colspan= 32>(<td  colspan= 24><pre> </pre><td  colspan= 36><pre> </pre>
<tr><td  colspan= 16><pre> </pre><td  colspan= 34><pre> </pre><td align=center colspan= 38><pre> </pre><td align=center colspan= 38><pre> </pre><td align=center colspan= 34><pre> </pre>
<tr><td align=center colspan= 160><B>Станции резервирования</B>
<tr><td align=center colspan= 16><B>Имя</B><td align=center colspan= 22><B>Занятость</B><td align=center colspan= 17><B>Fm</B><td align=center colspan= 39><B>V<SUB>j</B></SUB><td align=center colspan= 24><B>V<SUB>k</B></SUB><td align=center colspan= 20><B>Q<SUB>j</B></SUB><td align=center colspan= 22><B>Q<SUB>k</B></SUB>
<tr><td align=center colspan= 16>Add1<td align=center colspan= 22>Нет<td align=center colspan= 17><pre> </pre><td align=center colspan= 39>Mem[34+Regs[R2]]<td align=center colspan= 24><pre> </pre><td align=center colspan= 20><pre> </pre><td align=center colspan= 22><pre> </pre>
<tr><td align=center colspan= 16>Add2<td align=center colspan= 22>Нет<td align=center colspan= 17><pre> </pre><td align=center colspan= 39><pre> </pre><td align=center colspan= 24><pre> </pre><td align=center colspan= 20><pre> </pre><td align=center colspan= 22><pre> </pre>
<tr><td align=center colspan= 16>Add3<td align=center colspan= 22>Нет<td align=center colspan= 17><pre> </pre><td align=center colspan= 39><pre> </pre><td align=center colspan= 24><pre> </pre><td align=center colspan= 20><pre> </pre><td align=center colspan= 22><pre> </pre>
<tr><td align=center colspan= 16>Mult1<td align=center colspan= 22>Да<td align=center colspan= 17>MULT<td align=center colspan= 39><pre> </pre><td align=center colspan= 24>Regs[F2]<td align=center colspan= 20>Load1<td align=center colspan= 22><pre> </pre>
<tr><td align=center colspan= 16>Mult2<td align=center colspan= 22>Да<td align=center colspan= 17>MULT<td align=center colspan= 39><pre> </pre><td align=center colspan= 24>Regs[F2]<td align=center colspan= 20>Load2<td align=center colspan= 22><pre> </pre>
<tr><td align=center colspan= 16><pre> </pre><td align=center colspan= 22><pre> </pre><td align=center colspan= 17><pre> </pre><td align=center colspan= 39><pre> </pre><td align=center colspan= 24><pre> </pre><td align=center colspan= 20><pre> </pre><td align=center colspan= 22><pre> </pre>
<tr><td align=center colspan= 160><B>Состояние регистров</B>
<tr><td align=center colspan= 16><B>Поле</B><td align=center colspan= 16><B>F0</B><td align=center colspan= 16><B>F2</B><td align=center colspan= 16><B>F4</B><td align=center colspan= 16><B>F6</B><td align=center colspan= 16><B>F8</B><td align=center colspan= 16><B>F10</B><td align=center colspan= 16><B>F12</B><td align=center colspan= 12><B>. . .</B><td align=center colspan= 20><B>F30</B>
<tr><td align=center colspan= 16>Qi<td align=center colspan= 16>Load2<td align=center colspan= 16><pre> </pre><td align=center colspan= 16>Mult2<td align=center colspan= 16><pre> </pre><td align=center colspan= 16><pre> </pre><td align=center colspan= 16><pre> </pre><td align=center colspan= 16><pre> </pre><td align=center colspan= 12><pre> </pre><td align=center colspan= 20><pre> </pre>
<tr><td align=center colspan= 66><pre> </pre><td align=center colspan= 16><pre> </pre><td align=center colspan= 16><pre> </pre><td align=center colspan= 62><pre> </pre>
<tr><td align=center colspan= 75><B>Буфера загрузки</B><td align=center colspan= 7><pre> </pre><td align=center colspan= 4><pre> </pre><td align=center colspan= 74><B>Буфера записи</B>
<tr><td align=center colspan= 16><B>Поле</B><td align=center colspan= 19><B>Load1</B><td align=center colspan= 22><B>Load2</B><td align=center colspan= 17><B>Load3</B><td align=center colspan= 7><pre> </pre><td align=center colspan= 4><pre> </pre><td align=center colspan= 15><B>Поле</B><td align=center colspan= 22><B>Store1</B><td align=center colspan= 21><B>Store2</B><td align=center colspan= 17><B>Store3</B>
<tr><td align=center colspan= 16>Адрес<td align=center colspan= 19>Regs[R1]<td align=center colspan= 22>Regs[R1]-8<td align=center colspan= 17><pre> </pre><td align=center colspan= 7><pre> </pre><td align=center colspan= 4><pre> </pre><td align=center colspan= 15>Q<SUB>i</SUB><td align=center colspan= 22>Mult1<td align=center colspan= 21>Mult2<td align=center colspan= 17><pre> </pre>
<tr><td align=center colspan= 16>Заня-тость<td align=center colspan= 19>Да<td align=center colspan= 22>Да<td align=center colspan= 17>Нет<td align=center colspan= 7><pre> </pre><td align=center colspan= 4><pre> </pre><td align=center colspan= 15>Заня-тость<td align=center colspan= 22>Да<td align=center colspan= 21>Да<td align=center colspan= 17>Нет
<tr><td align=center colspan= 16><pre> </pre><td align=center colspan= 19><pre> </pre><td align=center colspan= 22><pre> </pre><td align=center colspan= 17><pre> </pre><td align=center colspan= 7><pre> </pre><td align=center colspan= 4><pre> </pre><td align=center colspan= 15>Адрес<td align=center colspan= 22>Regs[R1]<td align=center colspan= 21>Regs[R1]-8<td align=center colspan= 17><pre> </pre>
</table>
<P ALIGN = center>
<I>Рис. 6.7. Состояние станций резервирования, регистров и буферов загрузки/записи</I>
<P>
Эта динамическая схема может достигать очень высокой производительности при условии того, что стоимость переходов может поддерживаться небольшой. Этот вопрос мы будем рассматривать в следующем разделе. Главный недостаток этого подхода заключается в сложности схемы Томасуло, которая требует для своей реализации очень большого объема аппаратуры. Особенно это касается большого числа устройств ассоциативной памяти, которая должна работать с высокой скоростью, а также сложной логики управления. Наконец, увеличение производительности ограничивается наличием одной шины завершения (CDB). Хотя дополнительные шины CDB могут быть добавлены, каждая CDB должна взаимодействовать со всей аппаратурой конвейера, включая станции резервирования. В частности, аппаратуру ассоциативного сравнения необходимо дублировать на каждой станции для каждой CDB.
<P>
В схеме Томасуло комбинируются две различных методики: методика переименования регистров буферизация операндов-источников из регистрового файла. Буферизация источников операндов разрешает конфликты типа WAR, которые возникают когда операнды доступны в регистрах. Как мы увидим позже, возможно также устранять конфликты типа WAR посредством переименования регистра вместе с буферизацией результата до тех пор, пока остаются обращения к старой версии регистра; этот подход будет использоваться, когда мы будем обсуждать аппаратное выполнение по предположению.
<P>
Схема Томасуло является привлекательной, если разработчик вынужден делать конвейерную архитектуру, для которой трудно выполнить планирование кода или реализовать большое хранилище регистров. С другой стороны, преимущество подхода Томасуло возможно ощущается меньше, чем увеличение стоимости реализации, по сравнению с методами планирования загрузки конвейера средствами компилятора в машинах, ориентированных на выдачу для выполнения только одной команды в такте. Однако по мере того, как машины становятся все более агрессивными в своих возможностях выдачи команд и разработчики сталкиваются с вопросами производительности кода, который трудно планировать (большинство кодов для нечисловых расчетов), методика типа переименования регистров и динамического планирования будет становиться все более важной. Позже в этой главе мы увидим, что эти методы являются одним из важных компонентов большинства схем для реализации аппаратного выполнения по предположению.
<P>
Ключевыми компонентами увеличения параллелизма уровня команд в алгоритме Томасуло являются динамическое планирование, переименование регистров и динамическое устранение неоднозначности обращений к памяти. Трудно оценить значение каждого из этих свойств по отдельности.
<P>
Динамической аппаратной технике планирования загрузки конвейера при наличии зависимостей по данным соответствует и динамическая техника для эффективной обработки переходов. Эта техника используется для двух целей: для прогнозирования того, будет ли переход выполняемым, и для возможно более раннего нахождения целевой команды перехода. Эта техника называется аппаратным прогнозированием переходов.
<H3><A NAME = "Аппаратное прогнозирование направления переходов и снижение потерь на организацию переходов">Аппаратное прогнозирование направления переходов и снижение потерь на организацию переходов</A></H3>
<P>
<B>Буфера прогнозирования условных переходов</B>
<P>
Простейшей схемой динамического прогнозирования направления условных переходов является буфер прогнозирования условных переходов (branch-prediction buffer) или таблица &quot;истории&quot; условных переходов (branch history table). Буфер прогнозирования условных переходов представляет собой небольшую память, адресуемую с помощью младших разрядов адреса команды перехода. Каждая ячейка этой памяти содержит один бит, который говорит о том, был ли предыдущий переход выполняемым или нет. Это простейший вид такого рода буфера. В нем отсутствуют теги, и он оказывается полезным только для сокращения задержки перехода в случае, если эта задержка больше, чем время, необходимое для вычисления значения целевого адреса перехода. В действительности мы не знаем, является ли прогноз корректным (этот бит в соответствующую ячейку буфера могла установить совсем другая команда перехода, которая имела то же самое значение младших разрядов адреса). Но это не имеет значения. Прогноз - это только предположение, которое рассматривается как корректное, и выборка команд начинается по прогнозируемому направлению. Если же предположение окажется неверным, бит прогноза инвертируется. Конечно такой буфер можно рассматривать как кэш-память, каждое обращение к которой является попаданием, и производительность буфера зависит от того, насколько часто прогноз применялся и насколько он оказался точным.
<P>
Однако простая однобитовая схема прогноза имеет недостаточную производительность. Рассмотрим, например, команду условного перехода в цикле, которая являлась выполняемым переходом последовательно девять раз подряд, а затем однажды невыполняемым. Направление перехода будет неправильно предсказываться при первой и при последней итерации цикла. Неправильный прогноз последней итерации цикла неизбежен, поскольку бит прогноза будет говорить, что переход &quot;выполняемый&quot; (переход был девять раз подряд выполняемым). Неправильный прогноз на первой итерации происходит из-за того, что бит прогноза инвертируется при предыдущем выполнении последней итерации цикла, поскольку в этой итерации переход был невыполняемым. Таким образом, точность прогноза для перехода, который выполнялся в 90% случаев, составила только 80% (2 некорректных прогноза и 8 корректных). В общем случае, для команд условного перехода, используемых для организации циклов, переход является выполняемым много раз подряд, а затем один раз оказывается невыполняемым. Поэтому однобитовая схема прогнозирования будет неправильно предсказывать направление перехода дважды (при первой и при последней итерации).
<P>
Для исправления этого положения часто используется схема двухбитового прогноза. В двухбитовой схеме прогноз должен быть сделан неверно дважды, прежде чем он изменится на противоположное значение. На рис. 6.8 представлена диаграмма состояний двухбитовой схемы прогнозирования направления перехода.
<P>
<CENTER><IMG SRC = "img00014.gif" BORDER = 1 ></CENTER>

<P ALIGN = center>
<I>Рис. 6.8. Диаграмма состояния двухбитовой схемы прогнозирования</I>
<P>
Двухбитовая схема прогнозирования в действительности является частным случаем более общей схемы, которая в каждой строке буфера прогнозирования имеет n-битовый счетчик. Этот счетчик может принимать значения от 0 до 2<SUP>n</SUP> - 1. Тогда схема прогноза будет следующей:
<UL TYPE = disc>
<LI>Если значение счетчика больше или равно 2<SUP>n-1</SUP> (точка на середине интервала), то переход прогнозируется как выполняемый. Если направление перехода предсказано правильно, к значению счетчика добавляется единица (если только оно не достигло максимальной величины); если прогноз был неверным, из значения счетчика вычитается единица.
<LI>Если значение счетчика меньше, чем 2<SUP>n-1</SUP>, то переход прогнозируется как невыполняемый. Если направление перехода предсказано правильно, из значения счетчика вычитается единица (если только не достигнуто значение 0); если прогноз был неверным, к значению счетчика добавляется единица.
</UL>
<P>
Исследования n-битовых схем прогнозирования показали, что двухбитовая схема работает почти также хорошо, и поэтому в большинстве систем применяются двухбитовые схемы прогноза, а не n-битовые.
<P>
Буфер прогнозирования переходов может быть реализован в виде небольшой специальной кэш-памяти, доступ к которой осуществляется с помощью адреса команды во время стадии выборки команды в конвейере (IF), или как пара битов, связанных с каждым блоком кэш-памяти команд и выбираемых с каждой командой. Если команда декодируется как команда перехода, и если переход спрогнозирован как выполняемый, выборка команд начинается с целевого адреса как только станет известным новое значение счетчика команд. В противном случае продолжается последовательная выборка и выполнение команд. Если прогноз оказался неверным, значение битов прогноза меняется в соответствии с рис. 6.8. Хотя эта схема полезна для большинства конвейеров, рассмотренный нами простейший конвейер выясняет примерно за одно и то же время оба вопроса: является ли переход выполняемым и каков целевой адрес перехода (предполагается отсутствие конфликта при обращении к регистру, определенному в команде условного перехода. Напомним, что для простейшего конвейера это справедливо, поскольку условный переход выполняет сравнение содержимого регистра с нулем во время стадии ID, во время которой вычисляется также и эффективный адрес). Таким образом, эта схема не помогает в случае простых конвейеров, подобных рассмотренному ранее.
<P>
Как уже упоминалось, точность двухбитовой схемы прогнозирования зависит от того, насколько часто прогноз каждого перехода является правильным и насколько часто строка в буфере прогнозирования соответствует выполняемой команде перехода. Если строка не соответствует данной команде перехода, прогноз в любом случае делается, поскольку все равно никакая другая информация не доступна. Даже если эта строка соответствует совсем другой команде перехода, прогноз может быть удачным.
<P>
Какую точность можно ожидать от буфера прогнозирования переходов на реальных приложениях при использовании 2 бит на каждую строку буфера? Для набора оценочных тестов SPEC-89 буфер прогнозирования переходов с 4096 строками дает точность прогноза от 99% до 82%, т.е. процент неудачных прогнозов составляет от 1% до 18% (см. рис. 6.9). Следует отметить, что буфер емкостью 4К строк считается очень большим. Буферы меньшего объема дадут худшие результаты.
<P>
Однако одного знания точности прогноза не достаточно для того, чтобы определить воздействие переходов на производительность машины, даже если известны время выполнения перехода и потери при неудачном прогнозе. Необходимо учитывать частоту переходов в программе, поскольку важность правильного прогноза больше в программах с большей частотой переходов. Например, целочисленные программы li, eqntott, expresso и gcc имеют большую частоту переходов, чем значительно более простые для прогнозирования программы плавающей точки nasa7, matrix300 и tomcatv.
<P>
Поскольку главной задачей является использование максимально доступной степени параллелизма программы, точность прогноза направления переходов становится очень важной. Как видно из рис. 6.9, точность схемы прогнозирования для целочисленных программ, которые обычно имеют более высокую частоту переходов, меньше, чем для научных программ с плавающей точкой, в которых интенсивно используются циклы. Можно решать эту проблему двумя способами: увеличением размера буфера и увеличением точности схемы, которая используется для выполнения каждого отдельного прогноза. Буфер с 4К строками уже достаточно большой и, как показывает рис. 6.9, работает практически также, что и буфер бесконечного размера. Из этого рисунка становится также ясно, что коэффициент попаданий буфера не является лимитирующим фактором. Как мы упоминали выше, увеличение числа бит в схеме прогноза также имеет малый эффект.
<P ALIGN = center>
<CENTER><IMG SRC = "img00015.gif" BORDER = 1 ></CENTER>

<P ALIGN = center>
<I>Рис. 6.9. Сравнение качества 2-битового прогноза</I>
<P>
Рассмотренные двухбитовые схемы прогнозирования используют информацию о недавнем поведении команды условного перехода для прогноза будущего поведения этой команды. Вероятно можно улучшить точность прогноза, если учитывать не только поведение того перехода, который мы пытаемся предсказать, но рассматривать также и недавнее поведение других команд перехода. Рассмотрим, например, небольшой фрагмент из текста программы eqntott тестового пакета SPEC92 (это наихудший случай для двухбитовой схемы прогноза):
<P>
if (aa==2)
<P>
aa=0;
<P>
if (bb==2)
<P>
bb=0;
<P>
if (aa!=bb) {
<P>
Ниже приведен текст сгенерированной программы (предполагается, что aa и bb размещены в регистрах R1 и R2):
<P>
SUBI R3,R1,#2
<P>
BNEZ R3,L1 ; переход b1 (aa!=2)
<P>
ADD R1,R0,R0 ; aa=0
<P>
L1: SUBI R3,R2,#2
<P>
BNEZ R3,L2 ; переход b2 (bb!=2)
<P>
ADD R2,R0,R0 ; bb=0
<P>
L2: SUB R3,R1,R2 ; R3=aa-bb
<P>
BEQZ R3,L3 ; branch b3 (aa==bb).
<P>
...
<P>
L3:
<P>
Пометим команды перехода как b1, b2 и b3. Можно заметить, что поведение перехода b3 коррелирует с переходами b1 и b2. Ясно, что если оба перехода b1 и b2 являются невыполняемыми (т.е. оба условия if оцениваются как истинные и обеим переменным aa и bb присвоено значение 0), то переход b3 будет выполняемым, поскольку aa и bb очевидно равны. Схема прогнозирования, которая для предсказания направления перехода использует только прошлое поведение того же перехода никогда этого не учтет.
<P>
Схемы прогнозирования, которые для предсказания направления перехода используют поведение других команд перехода, называются коррелированными или двухуровневыми схемами прогнозирования. Схема прогнозирования называется прогнозом (1,1), если она использует поведение одного последнего перехода для выбора из пары однобитовых схем прогнозирования на каждый переход. В общем случае схема прогнозирования (m,n) использует поведение последних m переходов для выбора из 2<SUP>m</SUP> схем прогнозирования, каждая из которых представляет собой n-битовую схему прогнозирования для каждого отдельного перехода. Привлекательность такого типа коррелируемых схем прогнозирования переходов заключается в том, что они могут давать больший процент успешного прогнозирования, чем обычная двухбитовая схема, и требуют очень небольшого объема дополнительной аппаратуры. Простота аппаратной схемы определяется тем, что глобальная история последних m переходов может быть записана в m-битовом сдвиговом регистре, каждый разряд которого запоминает, был ли переход выполняемым или нет. Тогда буфер прогнозирования переходов может индексироваться конкатенацией (объединением) младших разрядов адреса перехода с m-битовой глобальной историей. Например, на рис. 6.10. показана схема прогнозирования (2,2) и организация выборки битов прогноза.
<P>
<CENTER><IMG SRC = "img00016.gif" BORDER = 1 ></CENTER>

<P ALIGN = center>
<I>Рис. 6.10. Буфер прогнозирования переходов (2,2)</I>
<P>
В этой реализации имеется тонкий эффект: поскольку буфер прогнозирования не является кэш-памятью, счетчики, индексируемые единственным значением глобальной схемы прогнозирования, могут в действительности в некоторый момент времени соответствовать разным командам перехода; это не отличается от того, что мы видели и раньше: прогноз может не соответствовать текущему переходу. На рис. 6.10 с целью упрощения понимания буфер изображен как двумерный объект. В действительности он может быть реализован просто как линейный массив двухбитовой памяти; индексация выполняется путем конкатенации битов глобальной истории и соответствующим числом бит, требуемых от адреса перехода. Например, на рис. 6.9 в буфере (2,2) с общим числом строк, равным 64, четыре младших разряда адреса команды перехода и два бита глобальной истории формируют 6-битовый индекс, который может использоваться для обращения к 64 счетчикам.
<P>
Насколько лучше схемы с корреляцией переходов работают по сравнению со стандартной духбитовой схемой? Чтобы их справедливо сравнить, нужно сопоставить схемы прогнозирования, использующие одинаковое число бит состояния. Число бит в схеме прогнозирования (m,n) равно 2<SUP>m</SUP> ( n ( количество строк, выбираемых с помощью адреса перехода.
<P>
Например, двухбитовая схема прогнозирования без глобальной истории есть просто схема (0,2). Сколько бит требуется для реализации схемы прогнозирования (0,2), которую мы рассматривали раньше? Сколько бит используется в схеме прогнозирования, показанной на рис. 6.10?
<P>
Раньше мы рассматривали схему прогнозирования с 4К строками, выбираемыми адресом перехода. Таким образом общее количество бит равно: 2<SUP>0</SUP> ( 2 ( 4K = 8K.
<P>
Схема на рис. 6.10. имеет 2<SUP>2</SUP> ( 2 ( 16 = 128 бит.
<P>
Чтобы сравнить производительность схемы коррелированного прогнозирования с простой двухбитовой схемой прогнозирования, производительность которой была представлена на рис. 6.8, нужно определить количество строк в схеме коррелированного прогнозирования.
<P>
Таким образом, мы должны определить количество строк, выбираемых командой перехода в схеме прогнозирования (2,2), которая содержит 8К бит в буфере прогнозирования.
<P>
Мы знаем, что
<P>
2<SUP>2</SUP> ( 2 ( количество строк, выбираемых
<br>
<P>
командой перехода = 8К
<P>
Поэтому
<P>
Количество строк, выбираемых командой
<br>
<P>
перехода = 1К.
<P>
На рис. 6.9 представлены результаты для сравнения простой двухбитовой схемы прогнозирования с 4К строками и схемы прогнозирования (2,2) с 1К строками. Как можно видеть, эта последняя схема прогнозирования не только превосходит простую двухбитовую схему прогнозирования с тем же самым количеством бит состояния, но часто превосходит даже двухбитовую схему прогнозирования с неограниченным (бесконечным) количеством строк. Имеется широкий спектр корреляционных схем прогнозирования, среди которых схемы (0,2) и (2,2) являются наиболее интересными.
<P>
<B>Дальнейшее уменьшение приостановок по управлению: буфера целевых адресов переходов</B>
<P>
Рассмотрим ситуацию, при которой на стадии выборки команд находится команда перехода (на следующей стадии будет осуществляться ее дешифрация). Тогда чтобы сократить потери, необходимо знать, по какому адресу выбирать следующую команду. Это означает, что нам как-то надо выяснить, что еще недешифрированная команда в самом деле является командой перехода, и чему равно следующее значение счетчика адресов команд. Если все это мы будем знать, то потери на команду перехода могут быть сведены к нулю. Специальный аппаратный кэш прогнозирования переходов, который хранит прогнозируемый адрес следующей команды, называется буфером целевых адресов переходов (branch-target buffer).
<P>
Каждая строка этого буфера включает программный адрес команды перехода, прогнозируемый адрес следующей команды и предысторию команды перехода (рис. 6.11)<B>.</B> Биты предыстории представляют собой информацию о выполнении или невыполнении условий перехода данной команды в прошлом. Обращение к буферу целевых адресов перехода (сравнение с полями программных адресов команд перехода) производится с помощью текущего значения счетчика команд на этапе выборки очередной команды. Если обнаружено совпадение (попадание в терминах кэш-памяти), то по предыстории команды прогнозируется выполнение или невыполнение условий команды перехода, и немедленно производится выборка и дешифрация команд из прогнозируемой ветви программы. Считается, что предыстория перехода, содержащая информацию о двух предшествующих случаях выполнения этой команды, позволяет прогнозировать развитие событий с вполне достаточной вероятностью.
<P>
<CENTER><IMG SRC = "img00017.gif" BORDER = 1 ></CENTER>

<P ALIGN = center>
<I>Рис. 6.11. Буфер целевых адресов переходов</I>
<P>
Существуют и некоторые вариации этого метода. Основной их смысл заключается в том, чтобы хранить в процессоре одну или несколько команд из прогнозируемой ветви перехода. Этот метод может применяться как в совокупности с буфером целевых адресов перехода, так и без него, и имеет два преимущества. Во-первых, он позволяет выполнять обращения к буферу целевых адресов перехода в течение более длительного времени, а не только в течение времени последовательной выборки команд. Это позволяет реализовать буфер большего объема. Во-вторых, буферизация самих целевых команд позволяет использовать дополнительный метод оптимизации, который называется свертыванием переходов (branch folding). Свертывание переходов может использоваться для реализации нулевого времени выполнения самих команд безусловного перехода, а в некоторых случаях и нулевого времени выполнения условных переходов. Рассмотрим буфер целевых адресов перехода, который буферизует команды из прогнозируемой ветви. Пусть к нему выполняется обращение по адресу команды безусловного перехода. Единственной задачей этой команды безусловного перехода является замена текущего значения счетчика команд. В этом случае, когда буфер адресов регистрирует попадание и показывает, что переход безусловный, конвейер просто может заменить команду, которая выбирается из кэш-памяти (это и есть сама команда безусловного перехода), на команду из буфера. В некоторых случаях таким образом удается убрать потери для команд условного перехода, если код условия установлен заранее.
<P>
Еще одним методом уменьшения потерь на переходы является метод прогнозирования косвенных переходов, а именно переходов, адрес назначения которых меняется в процессе выполнения программы (в run-time). Компиляторы языков высокого уровня будут генерировать такие переходы для реализации косвенного вызова процедур, операторов select или case и вычисляемых операторов goto в Фортране. Однако подавляющее большинство косвенных переходов возникает в процессе выполнения программы при организации возврата из процедур. Например, для тестовых пакетов SPEC возвраты из процедур в среднем составляют 85% общего числа косвенных переходов.
<P>
Хотя возвраты из процедур могут прогнозироваться с помощью буфера целевых адресов переходов, точность такого метода прогнозирования может оказаться низкой, если процедура вызывается из нескольких мест программы или вызовы процедуры из одного места программы не локализуются по времени. Чтобы преодолеть эту проблему, была предложена концепция небольшого буфера адресов возврата, работающего как стек. Эта структура кэширует последние адреса возврата: во время вызова процедуры адрес возврата вталкивается в стек, а во время возврата он оттуда извлекается. Если этот кэш достаточно большой (например, настолько большой, чтобы обеспечить максимальную глубину вложенности вызовов), он будет прекрасно прогнозировать возвраты. На рис. 6.12 показано исполнение такого буфера возвратов, содержащего от 1 до 16 строк (элементов) для нескольких тестов SPEC.
<P ALIGN = center>
<CENTER><IMG SRC = "img00018.gif" BORDER = 1 ></CENTER>

<P ALIGN = center>
<I>Рис. 6.12. Точность прогноза для адресов возврата</I>
<P>
Точность прогноза в данном случае есть доля адресов возврата, предсказанных правильно. Поскольку глубина вызовов процедур обычно не большая, за некоторыми исключениями даже небольшой буфер работает достаточно хорошо. В среднем возвраты составляют 81% общего числа косвенных переходов для этих шести тестов.
<P>
Схемы прогнозирования условных переходов ограничены как точностью прогноза, так и потерями в случае неправильного прогноза. Как мы видели, типичные схемы прогнозирования достигают точности прогноза в диапазоне от 80 до 95% в зависимости от типа программы и размера буфера. Кроме увеличения точности схемы прогнозирования, можно пытаться уменьшить потери при неверном прогнозе. Обычно это делается путем выборки команд по обоим ветвям (по предсказанному и по непредсказанному направлению). Это требует, чтобы система памяти была двухпортовой, включала кэш-память с расслоением, или осуществляла выборку по одному из направлений, а затем по другому (как это делается в IBM POWER-2). Хотя подобная организация увеличивает стоимость системы, возможно это единственный способ снижения потерь на условные переходы ниже определенного уровня. Другое альтернативное решение, которое используется в некоторых машинах, заключается в кэшировании адресов или команд из нескольких направлений (ветвей) в целевом буфере.
<p><center><font size="-1">[<a href="glava_6.htm">Предыдущая глава</a>] [<a href="contents.htm"> Оглавление</a>] [<a href="glava_7.htm">Следующая глава</a>]
</font></center>

</body></html>
